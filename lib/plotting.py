import numpy as np
import os
import matplotlib
matplotlib.use('Agg')
from scipy.stats import ks_2samp
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns


def plotter(out_dir, method, transformer, real_subset, real_subset_labels, 
            fake_subset, fake_subset_labels, num_experts, num_subpopulations, iteration, logger, zero_sub=False):
    """ Generates plots for each expert based on given method 
    :param out_dir: results directory
    :param method: What type of plot (one of {pca, umap, tsne})
    :param transformer: An object with transform method accompanying the method
    :param real_subset: The sampled subset of real data
    :param real_subset_labels: Subpopulations associated with each cell in real subset
    :param fake_subset: Fake data from the generator 
    :param fake_subset_labels: Which expert generates which cell in fake data
    :param num_experts: Number of experts used
    :param num_subpopulations: Number of subpopulations in the data
    :param iteration: which iteration of training are we at
    :param logger: logger used
    :param zero_sub: Whether subpopulations labelled from 0 or 1

    """
    
    # The actual directory where results are saved
    save_dir = os.path.join(out_dir, str((iteration // 100) + 1))

    # Create a separate directory for the method 
    method_dir = os.path.join(save_dir, method + '_plots')
    
    # Transform data according to transformer based on method
    transformed_real = transformer.transform(real_subset)
    transformed_fake = transformer.transform(fake_subset)

    for expert in range(num_experts):
        
        # A directory for each expert
        expert_dir = os.path.join(method_dir, 'Expert_{}'.format(expert+1))
        if not os.path.exists(expert_dir):
            os.makedirs(expert_dir)
        
        # Finds the data generated by expert
        indices = np.flatnonzero(fake_subset_labels == expert)
        fake_data_by_expert = transformed_fake[indices]

        for subpopulation in range(num_subpopulations):
            
            # Checks for 0/1 based subpopulation numbering and gets data corresponding to the subpopulation
            if zero_sub:
                indices = np.flatnonzero(real_subset_labels == subpopulation)
            else:
                indices = np.flatnonzero(real_subset_labels == subpopulation + 1)
            
            real_data_by_sub = transformed_real[indices]

            f, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 10))

            # Second plot (Real Subpopulation, Fake Data)
            axes[1].scatter(real_data_by_sub[:, 0], real_data_by_sub[:, 1], c='tab:blue',
                            label='Subpopulation {}'.format(subpopulation+1))
            axes[1].scatter(fake_data_by_expert[:, 0], fake_data_by_expert[:, 1], c='tab:orange',
                            label='Expert {}'.format(expert+1))
            axes[1].set_xlabel('PC1')
            axes[1].set_ylabel('PC2')
            axes[1].legend()

            # First plot
            xmin, xmax = axes[1].get_xlim()
            ymin, ymax = axes[1].get_ylim()

            axes[0].scatter(real_data_by_sub[:, 0], real_data_by_sub[:, 1], c='tab:gray',
                            label='Subpopulation {}'.format(subpopulation+1))
            axes[0].set_xlim([xmin, xmax])
            axes[0].set_ylim([ymin, ymax])
            axes[0].set_xlabel('PC1')
            axes[0].set_ylabel('PC2')
            axes[0].legend()

            savefile = os.path.join(expert_dir, 'Subpopulation_{}.png'.format(subpopulation+1))
            f.tight_layout()
            plt.savefig(savefile)
            plt.close()

        logger.info(method.upper() + ' plots added for expert {}'.format(str(expert+1)))
    logger.info("\n")


def plot_pca(out_dir, pca_obj, real_subset, real_subset_labels, fake_subset,
             fake_subset_labels, num_experts, num_subpopulations, iteration, logger, zero_sub=False):
    """ Generates the PCA plot for each expert """

    plotter(out_dir=out_dir, method='pca', transformer=pca_obj, 
            real_subset=real_subset, real_subset_labels=real_subset_labels, 
            fake_subset=fake_subset, fake_subset_labels=fake_subset_labels, 
            num_experts=num_experts, num_subpopulations=num_subpopulations, 
            iteration=iteration, logger=logger, zero_sub=zero_sub)


def plot_umap(out_dir, umap_obj, real_subset, real_subset_labels, fake_subset,
              fake_subset_labels, num_experts, num_subpopulations, iteration, logger, zero_sub=False):
    """ Generates the UMAP plot """
    
    plotter(out_dir=out_dir, method='umap', transformer=umap_obj, 
            real_subset=real_subset, real_subset_labels=real_subset_labels, 
            fake_subset=fake_subset, fake_subset_labels=fake_subset_labels, 
            num_experts=num_experts, num_subpopulations=num_subpopulations, 
            iteration=iteration, logger=logger, zero_sub=zero_sub)


def plot_tsne(out_dir, tsne_obj, real_subset, real_subset_labels, fake_subset,
              fake_subset_labels, num_experts, num_subpopulations, iteration, logger, zero_sub=False):
    """ Generates the tsne plot """

    plotter(out_dir=out_dir, method='tsne', transformer=tsne_obj, 
            real_subset=real_subset, real_subset_labels=real_subset_labels, 
            fake_subset=fake_subset, fake_subset_labels=fake_subset_labels, 
            num_experts=num_experts, num_subpopulations=num_subpopulations,
            iteration=iteration, logger=logger)


def plot_marker_distributions(out_dir,
                              real_subset,
                              fake_subset,
                              fake_subset_labels,
                              real_subset_labels,
                              num_subpopulations,
                              num_markers,
                              num_experts,
                              marker_names,
                              iteration,
                              logger,
                              zero_sub=False):
    """
    Plots the marker distribution per expert for each subpopulation and computes KS test and picks the best matching
    subpopulation for that expert
    :param out_dir: Output directory to save the plots to
    :param real_subset: Subset of real data
    :param fake_subset: Subset of fake data (generated by the GAN)
    :param fake_subset_labels: Which expert generated which data point
    :param real_subset_labels: Which subpopulation does the real data belong to
    :param num_subpopulations: Number of subpopulations in the training data
    :param num_markers: Number of markers whose distribution we tried to learn
    :param num_experts: Number of experts used in the generator
    :param marker_names: Names of markers
    :param iteration: iteration no.
    :param logger: logger used for logging results
    :param zero_sub: Whether the subpopulation labels start with zero or one
    :param pca: To add an additional plot with pca
    :return:
    """

    dirname = os.path.join(out_dir, str((iteration // 100) + 1))
    save_dir = os.path.join(dirname, 'distributions')

    if not os.path.exists(save_dir):
        os.makedirs(save_dir)

    for expert in range(num_experts):

        f, axes = plt.subplots(nrows=num_subpopulations, 
                ncols=num_markers, figsize=(30, 30))

        best_ks_sum = np.inf

        filename = os.path.join(save_dir, 'Expert_' + str(expert + 1) + '.png')
        indices = np.flatnonzero(fake_subset_labels == expert)

        # Fake data generated by expert in the GAN
        fake_data_by_expert = fake_subset[indices, :]

        for sub in range(num_subpopulations):

            if zero_sub:
                indices = np.flatnonzero(real_subset_labels == sub)
            else:
                indices = np.flatnonzero(real_subset_labels == (sub + 1))

            real_data_by_sub = real_subset[indices, :]

            ks_markers = list()

            for marker in range(num_markers):

                fake_max = np.max(fake_data_by_expert[:, marker])
                fake_min = np.min(fake_data_by_expert[:, marker])

                real_max = np.max(real_data_by_sub[:, marker])
                real_min = np.min(real_data_by_sub[:, marker])

                overall_max = max(real_max, fake_max)
                overall_min = min(real_min, fake_min)

                bins = np.linspace(overall_min, overall_max, num=30)

                w = np.ones_like(real_data_by_sub[:, marker]) / float(len(real_data_by_sub[:, marker]))
                axes[sub, marker].hist(real_data_by_sub[:, marker], bins=bins,
                                       weights=w, label='R',normed=0, alpha=0.5)

                w = np.ones_like(fake_data_by_expert[:, marker]) / float(len(fake_data_by_expert[:, marker]))
                axes[sub, marker].hist(fake_data_by_expert[:, marker], bins=bins,
                                       weights=w, label='F',normed=0, alpha=0.5)

                ks = ks_2samp(fake_data_by_expert[:, marker],
                              real_data_by_sub[:, marker])[0]
                ks_markers.append(ks)

                axes[sub, marker].set_xlim([overall_min, overall_max])
                ticks = np.linspace(overall_min, overall_max, num=5)
                axes[sub, marker].set_xticks(ticks.round(2))

                axes[sub, marker].set_title('{}'.format(marker_names[marker]))
                axes[sub, marker].set_ylabel(
                    'Subpopulation {}'.format(sub + 1))
                axes[sub, marker].legend()

            if np.sum(ks_markers) < best_ks_sum:
                best_ks_sum = np.sum(ks_markers)
                best_sub = sub

        for marker in range(num_markers):
            axes[best_sub, marker].spines['bottom'].set_color('0.0')
            axes[best_sub, marker].spines['top'].set_color('0.0')
            axes[best_sub, marker].spines['right'].set_color('0.0')
            axes[best_sub, marker].spines['left'].set_color('0.0')
            [i.set_linewidth(2.5) for i in axes[best_sub, marker].spines.values()]

        f.suptitle('Marker Distribution Plots per subpopulation', x=0.5, y=1.02, fontsize=20)
        f.tight_layout()
        plt.savefig(filename)
        plt.close()

        logger.info('Marker distribution plot for expert {} added.'.format(expert + 1))


def plot_heatmap(out_dir, logits, fake_subset_labels):

    """
    Heat map plot
    :param out_dir: str, output directory
    :param logits: Tensor, unnormalized log probs of an expert generating a cell
    :param fake_subset_labels: Which expert generates which cell
    """

    filename = os.path.join(out_dir, 'heatmap.png')
    unique_experts = np.unique(fake_subset_labels)
    expert_labels_series = pd.Series(fake_subset_labels)
    lut = dict(zip(expert_labels_series.unique(),
                   plt.cm.get_cmap('jet', len(unique_experts))(np.linspace(0, 1, len(unique_experts)))))

    row_colors = expert_labels_series.map(lut)
    plt.figure()

    g = sns.clustermap(logits, row_colors=list(row_colors),
                       yticklabels=False, xticklabels=True)

    for expert in unique_experts:
        g.ax_row_dendrogram.bar(0, 0, color=lut[expert], label=expert, linewidth=0)
    g.ax_row_dendrogram.legend(loc="best", ncol=1, fancybox=True, framealpha=0.5)
    plt.setp(g.ax_heatmap.get_xticklabels(), rotation=90)  # For x axis
    plt.rcParams["xtick.labelsize"] = 6.5
    plt.savefig(filename)
    plt.close()


def plot_loss(out_dir, disc_loss, gen_loss):
    """
    Saves loss plot to output directory
    :param out_dir: str, output directory
    :param disc_loss: list, discriminator losses
    :param gen_loss: list, generator losses
    :return: no returns
    """

    filename = os.path.join(out_dir, 'loss_plot.png')
    plt.plot(range(len(disc_loss)), disc_loss, 'r', label='Discriminator Loss')
    plt.plot(range(len(gen_loss)), gen_loss, 'b', label='Generator Loss')
    plt.xlabel('Number of Iterations')
    plt.ylabel('Loss')
    plt.legend()
    plt.savefig(filename)
    plt.close()

